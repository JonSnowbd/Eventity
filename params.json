{"name":"Eventity","tagline":"An Event based ECS system based on easy usage","body":"# Usage\r\n---\r\nEventity is an easy to use mix of Event, Entity, Component, and Systems. To get started all you need to do is import ecs from ECS.\r\n\r\n`from eventity import ecs`\r\n\r\nfrom here the world is your oyster. See subsections for information on each part of eventity.\r\n\r\n## Entities\r\n\r\nIn Eventity, entities are nothing more than an object with an ID and various methods to handle their relations to various components, which in turn are sets of data.\r\n\r\nTo create a new entity:\r\n`ecs.new()`\r\n\r\nor, to create a useful Named entity:\r\n`ecs.new(\"player\")`\r\n\r\nAccessing these entities are also super simple and inspired by Jquery:\r\n`ecs(\"player\")`\r\n\r\nEntities are in charge of adding components to themselves via the method `add()`.\r\n`ecs(\"player\").add(PositionComponent)`\r\n\r\nOr if you're getting fancy, you can chain both thew new and add methods:\r\n`ecs.new(\"player\").add(PositionComponent)`\r\n\r\nYou can also query Entities, with the `ecs.list([])` method. Forgoing parameters will simply return every entity\r\n\r\n## Components\r\n\r\nComponents are sets of data attached to entities. they comprise most of what an entity is. This is for things like positions, velocities, images, speech, anything. They are simple, plain dictionaries:\r\n```\r\nPositionComponent = {\r\n    \"name\": \"position\", # Its recommended to keep this snake_case\r\n    \"data\":{\r\n        \"x\": 0,\r\n        \"y\": 0\r\n    }\r\n}\r\necs(\"player\").add(PositionComponent)\r\n```\r\nEasy right? Hmm.. Now what if you didn't want player to start at 0,0? Well, it's easy:\r\n\r\n`ecs(\"player\").add(PositionComponent, { \"x\": 300, \"y\": 300 })`\r\n\r\nThe optional secondary parameter lets you override data from the Component itself.\r\n\r\n## Systems\r\n\r\nWell, we know the very basics of Entities and components. In a metaphor, I'd say Entities and Components are to Eventity what HTML and CSS are to Web development. They hold data but have no *real* interaction, no dynamic-ness.\r\n\r\nSystems are of course Javascript in this metaphor, they're going to drive our application. lets write a system that'll move player along the x axis every 'tick' or update.\r\n\r\n```\r\nfrom eventity import ecs, System\r\n\r\nPositionComponent = {\r\n    \"name\": \"position\",\r\n    \"data\":{\r\n        \"x\": 0,\r\n        \"y\": 0\r\n    }\r\n}\r\n\r\nclass MovementSystem(System):\r\n    def set_up(self, eventmanager):\r\n        self.limits = [\"position\"]\r\n        eventmanager.on(\"move\", self.move)\r\n    def move(self, data):\r\n        for entity in self.entities(): # This is sadly something you'll have to know exists\r\n            entity.position[\"x\"] += 10\r\n            print(\"moving \" + entity.id + \" to \" + str(entity.position))\r\n\r\necs.register(MovementSystem)\r\n\r\necs.new(\"player\").add(PositionComponent)\r\n\r\necs.send(\"move\")\r\necs.send(\"move\")\r\necs.send(\"move\")\r\n\r\n```\r\n\r\nNow, that wasn't *too* hard was it? Lets work through it.\r\n\r\n`class MovementSystem(System):`\r\nHere we extend System, which we imported from ECS, this handles a bit of the logic so you can keep your systems nice and clean.\r\n\r\n```\r\ndef set_up(self, eventmanager):\r\n    self.limits = [\"position\"]\r\n    eventmanager.on(\"move\", self.move)\r\n```\r\n\r\nFor systems, this will be your new constructor. This gets called by `System`'s `__init__`. Here we set limits for this system, we only want it to affect entities that have the `position` component on them. So, if we were to add a new entity with the position component, they too will get shifted 10 on their x axis. Give it a try!\r\n\r\nPassed into `set_up()` is the internal private Event Manager. This is your one shot at talking to it, so make it count. In this case we ask it to run `self.move(data)` when `ecs` is sent the \"move\" trigger. You can have as many triggers on one system as you like, but try to keep Systems short and concise to what it does.\r\n\r\n```\r\ndef move(data):\r\n    for entity in self.entities():\r\n        entity.position[\"x\"] += 10\r\n        print(\"moving \" + entity.id + \" to \" + str(entity.position))\r\n```\r\n\r\nHere we define the class method that the eventmanager will call when it hears \"move\". With most of these methods you'd receive the target in the data packet you send with `ecs.send(\"move\", { \"amount\": 30 })` but in this case we have no specific target, so we'll just query `ecs` for all the entities within our limits with `self.entities()`\r\n\r\nAs you can see, all the data belonging to each component is neatly stored within the class attribute of the same name as a dictionary, you can do anything you want with the data, just make sure you only adjust data of the components you specified in `self.limits = [\"position\"]`.\r\n\r\nIf you too dislike the 'magic' behind the mysterious self.entities which you didn't explicitly define, each system gets passed `ecs`, so you could very well just get rid of `self.limits = [\"position\"]` and do:\r\n```\r\ndef move(self, data):\r\n    for entity in self.ecs.list([\"position\"]):\r\n        entity.position[\"x\"] += 10\r\n        print(\"moving \" + entity.id + \" to \" + str(entity.position))\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}